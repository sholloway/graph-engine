package org.machine.engine.communication.routes

import akka.actor.ActorSystem
import akka.stream.{ActorMaterializer, Graph, FlowShape}
import akka.http.scaladsl.model.HttpMethods._
import akka.http.scaladsl.model._
import akka.http.scaladsl.model.ws.{BinaryMessage, Message, TextMessage, UpgradeToWebSocket}
import akka.http.scaladsl.unmarshalling.Unmarshal
import scala.collection.JavaConversions._
import scala.io.StdIn
import akka.stream.scaladsl.{Flow, Sink, Source}
import org.machine.engine.flow.{WebSocketFlow}

/*
Authentication Thoughts:
- Use basic auth to prevent a port scanner from attaching.
- Pass sessionID for actual request processing on all requests.
- SessionID generated by Identity Service.

Example for basic auth:
http://www.slideshare.net/luksow/practical-akka-http-introduction Slide15
*/
//TODO: Refactor into smaller classes and objects. This object should only have
//the routing logic.
//TODO: Re-write to use the Routing DSL with the WebSockets directives.
object WebSocketRouteBuilder{
  private implicit val system = ActorSystem()
  private implicit val materializer = ActorMaterializer()
  private val config = system.settings.config
  //All the subprotocols supported. Listed in descending priority.
  private val validSubprotocols:List[String] = config.getStringList("engine.communication.webserver.subprotocols").toList
  private val httpGetMsg = """
  |<html>
  | <body>
  |   This is a private channel for engine communication.
  | </body>
  |</html>""".stripMargin


  def buildRoutes():HttpRequest => HttpResponse ={
    val requestHandler: HttpRequest => HttpResponse = {
      case HttpRequest(GET, Uri.Path("/"), _, _, _) => handleRootRequest()
      case HttpRequest(GET, Uri.Path("/configuration"), _, _, _) => handleInfoRequest()
      case req @ HttpRequest(GET, Uri.Path("/ws"),_, _, _) => handleWebSocketRequest(req)
      case req @ HttpRequest(GET, Uri.Path("/ws/ping"),_, _, _) => handleWebSocketRequest(req)
      case _: HttpRequest =>
        HttpResponse(404, entity = "Unknown resource!")
    }
    return requestHandler
  }

  private def handleRootRequest(): HttpResponse = {
    return HttpResponse(entity = HttpEntity(ContentTypes.`text/html(UTF-8)`,httpGetMsg))
  }

  private def handleInfoRequest(): HttpResponse = {
    val msg = s"""
    |<html>
    | <body>
    |   <h1>Engine</h1>
    |   <hr/>
    |   Version: ${config.getString("engine.version")}
    | </body>
    |</html>
    """.stripMargin
    return HttpResponse(entity = HttpEntity(ContentTypes.`text/html(UTF-8)`,msg))
  }

  private def handleWebSocketRequest(req: HttpRequest):HttpResponse = {
    system.log.debug("handleWebSocketRequest")
    req.header[UpgradeToWebSocket] match {
      case Some(upgradeReqHeader) => attemptToUpgradeConnectToWS(req, upgradeReqHeader)
      case None => HttpResponse(400, entity = "Not a valid websocket request.")
    }
  }

  /*
  This function does not return immediately if the connection is established.
  */
  private def attemptToUpgradeConnectToWS(req: HttpRequest,
    upgradeReqHeader: UpgradeToWebSocket):HttpResponse = {
    system.log.info("Received request to upgrade to websocket.")

    if(upgradeReqHeader.requestedProtocols.length < 1){
      system.log.error("No subprotocol was provided by the client.")
      return HttpResponse(400, entity = "A valid subprotocol must be specified.")
    }else if(!validProtocolSpecified(upgradeReqHeader.requestedProtocols)){
      system.log.error("Unsupported protocol provided.")
      return HttpResponse(400, entity = "Unsupport subprotocol requested.")
    }
    val topLevelProtocolOption = selectTopProtocol(upgradeReqHeader.requestedProtocols)
    system.log.info("All good. Attempting to handle incoming messages.")

    val relativePath = req.uri.toRelative.toString
    relativePath match {
      /*
      NOTE: Might need to pivot design to leverage
      def handleMessagesWithSinkSource(inSink: Graph[SinkShape[Message], Any],
        outSource: Graph[SourceShape[Message], Any], subprotocol: Option[String] = None): HttpResponse
      */
      // case "/ws" => upgradeReqHeader.handleMessages(inboundStreamGraph(), topLevelProtocolOption)
      case "/ws" => upgradeReqHeader.handleMessages(WebSocketFlow.flow, topLevelProtocolOption)
      case "/ws/ping" => upgradeReqHeader.handleMessages(echo, topLevelProtocolOption)
      case rp => {
        system.log.error("Could not match the relative path of the request.")
        system.log.error(s"Relative Path was: $rp")
        return HttpResponse(400, entity = "Unsupport Relative Path")
      }
    }
  }

  private def validProtocolSpecified(clientProtocols: Seq[String]):Boolean = {
    system.log.info("Validating Subprotocol")
    return clientProtocols.intersect(validSubprotocols).length > 0
  }

  private def selectTopProtocol(clientProtocols: Seq[String]):Option[String] = {
    system.log.info("Attempting to select top subprotocol.")
    val protocolOption = validSubprotocols.collectFirst{
      case protocol if clientProtocols.contains(protocol) => protocol
    }
    system.log.info(s"Subprotocol selected: ${protocolOption.get}")
    return protocolOption
  }

  /*
  TODO:
  - Make aware of the subprotocol selection.
  - Build out to work with the Google protocol buffers.
  */
  private def inboundStreamGraph(): Graph[FlowShape[Message, Message], Any] = {
    system.log.info("Building Stream Graph")
    import org.machine.engine.graph.Neo4JHelper
    return Flow[Message]
      .mapConcat {
        // we match but don't actually consume the text message here,
        // rather we simply stream it back as the tail of the response
        // this means we might start sending the response even before the
        // end of the incoming message has been received
        //Neo4JHelper.uuid
        case tm: TextMessage => {
          //Return a new UUID. This is a reciept that the message was received.
          TextMessage(Source.single(Neo4JHelper.uuid)) :: Nil //Same as List[TextMessage](TextMessage(Source.single(Neo4JHelper.uuid)))
        }
        case bm: BinaryMessage => {
          // ignore binary messages but drain content to avoid the stream being clogged
          bm.dataStream.runWith(Sink.ignore)
          Nil //The response is an empty list...
        }
      }
   }

   //Simply return the message received.
   private def echo:Graph[FlowShape[Message, Message], Any] = {
     Flow[Message]
   }
}
